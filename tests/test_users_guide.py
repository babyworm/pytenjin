
###
### auto generated by ../doc/Kookbook.py
###

import sys, os, re
from glob import glob
import pytest

PYPY    = hasattr(sys, 'pypy_version_info')

from subprocess import Popen, PIPE

def _popen3(command):
    p = Popen(command, shell=True, close_fds=True,
              stdin=PIPE, stdout=PIPE, stderr=PIPE)
    return p


class TestUsersGuide:

    DIR = os.path.dirname(os.path.abspath(__file__)) + '/data/users_guide'
    CWD = os.getcwd()

    def setup_method(self, method):
        self.__name__ = method.__name__[len('test_'):]
        self._testMethodName = method.__name__
        sys.stdout.write(' (')
        os.chdir(self.DIR + '/test_' + self.__name__)
        for x in glob('*.cache') + glob('views/*.cache'):
            os.unlink(x)
        if self.__name__ == 'flexibleindent':
            for parent_dir in ['..', '../..', '../../..']:
                fname = parent_dir + '/my_template.py'
                if os.path.isfile(fname):
                    import shutil
                    shutil.copy(fname, 'my_template.py')
                    break
        if PYPY:
            if self.__name__ == 'syntaxerr':
                s = (
                    "$ pytenjin -z syntaxerr.pyhtml\n"
                    "syntaxerr.pyhtml:5:8: invalid syntax\n"
                    "  5:         else\n"
                    "            ^\n"
                    )
                with open('result.output', 'w') as f:
                    f.write(s)
                del s

    def teardown_method(self):
        os.chdir(self.CWD)

    def _test(self):
        result_files = sorted(glob('result*.output'))
        for fname in result_files:
            sys.stdout.write(' %s' % fname)
            with open(fname) as f:
                result = f.read()
            command, expected = re.split(r'\n', result, 1)
            command = re.sub(r'^\$ ', '', command)
            if self.__name__ == 'logging':
                proc = _popen3(command)
                proc.stdin.close()
                actual = proc.stdout.read() + proc.stderr.read()
                proc.stdout.close()
                proc.stderr.close()
                proc.wait()
                actual = actual.decode('utf-8')
                actual = re.sub(r'file=.*?/test_logging/', "file='/home/user/", actual)
            else:
                with os.popen(command) as p:
                    actual = p.read()
                if self.__name__ == 'm17n':
                    expected = re.sub(r'timestamp: \d+(\.\d+)?', 'timestamp: 0.0', expected)
                    actual   = re.sub(r'timestamp: \d+(\.\d+)?', 'timestamp: 0.0', actual)
            if self._testMethodName == 'test_nested':
                expected = re.sub(r'[ \t]*\#.*', '', expected)
            assert actual == expected
        if not result_files:
            fname = glob('*main*.py')[0]
            command = sys.executable + " " + fname
            with os.popen(command) as p:
                actual = p.read()
            fname = glob('*.expected')[0]
            with open(fname) as f:
                expected = f.read()
            assert actual == expected
        sys.stdout.write(' )')

    def test_010(self):
        self._test()

    def test_011(self):
        self._test()

    def test_020(self):
        self._test()

    def test_021(self):
        self._test()

    def test_030(self):
        self._test()

    def test_040(self):
        self._test()

    def test_050(self):
        self._test()

    def test_051(self):
        self._test()

    def test_060(self):
        self._test()

    def test_070(self):
        self._test()

    def test_capturing(self):
        self._test()

    def test_context(self):
        self._test()

    def test_convert(self):
        self._test()

    def test_escape(self):
        self._test()

    def test_execute(self):
        self._test()

    def test_fragmentcache(self):
        self._test()

    def test_logging(self):
        self._test()

    def test_m17n(self):
        self._test()

    def test_nested(self):
        self._test()

    def test_pp(self):
        self._test()

    def test_pp_javascript(self):
        self._test()

    def test_pp_prefixed(self):
        self._test()

    def test_pp_trim(self):
        self._test()

    def test_preprocessing(self):
        self._test()

    def test_retrieve(self):
        self._test()

    def test_safe(self):
        self._test()

    def test_syntax_check(self):
        self._test()

    def test_syntaxerr(self):
        self._test()

    def test_trace(self):
        self._test()
